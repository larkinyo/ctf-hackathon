import algosdk from 'algosdk';
import { Config } from '../config.mjs';
import { chunkArray } from '../util.mjs';
import { MAX_TRANSACTION_GROUP_SIZE } from './composer.mjs';

var AssetModel = algosdk.modelsv2.Asset;
/** Allows management of asset information. */
class AssetManager {
    /**
     * Create a new asset manager.
     * @param algod An algod client
     * @param newGroup A function that creates a new `AlgoKitComposer` transaction group
     * @example Create a new asset manager
     * ```typescript
     * const assetManager = new AssetManager(algod, () => new AlgoKitComposer({algod, () => signer, () => suggestedParams}))
     * ```
     */
    constructor(algod, newGroup) {
        this._algod = algod;
        this._newGroup = newGroup;
    }
    /**
     * Returns the current asset information for the asset with the given ID.
     *
     * @example
     * ```typescript
     * const assetInfo = await assetManager.getById(12353n);
     * ```
     *
     * @param assetId The ID of the asset
     * @returns The asset information
     */
    async getById(assetId) {
        const asset = AssetModel.from_obj_for_encoding(await this._algod.getAssetByID(Number(assetId)).do());
        return {
            assetId: BigInt(asset.index),
            total: BigInt(asset.params.total),
            decimals: Number(asset.params.decimals),
            assetName: asset.params.name,
            assetNameAsBytes: asset.params.nameB64,
            unitName: asset.params.unitName,
            unitNameAsBytes: asset.params.unitNameB64,
            url: asset.params.url,
            urlAsBytes: asset.params.urlB64,
            creator: asset.params.creator,
            manager: asset.params.manager,
            clawback: asset.params.clawback,
            freeze: asset.params.freeze,
            reserve: asset.params.reserve,
            defaultFrozen: asset.params.defaultFrozen,
            metadataHash: asset.params.metadataHash,
        };
    }
    /**
     * Returns the given sender account's asset holding for a given asset.
     *
     * @example
     * ```typescript
     * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
     * const assetId = 123345n;
     * const accountInfo = await algorand.asset.getAccountInformation(address, assetId);
     * ```
     *
     * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddressassetsasset-id)
     * @param sender The address of the sender/account to look up
     * @param assetId The ID of the asset to return a holding for
     * @returns The account asset holding information
     */
    async getAccountInformation(sender, assetId) {
        const info = await this._algod.accountAssetInformation(typeof sender === 'string' ? sender : sender.addr, Number(assetId)).do();
        return {
            assetId: BigInt(assetId),
            balance: BigInt(info['asset-holding']['amount']),
            frozen: info['asset-holding']['is-frozen'] === true,
            round: BigInt(info['round']),
        };
    }
    /**
     * Opt an account in to a list of Algorand Standard Assets.
     *
     * Transactions will be sent in batches of 16 as transaction groups.
     *
     * @param account The account to opt-in
     * @param assetIds The list of asset IDs to opt-in to
     * @param options Any parameters to control the transaction or execution of the transaction
     * @example Example using AlgorandClient
     * ```typescript
     * // Basic example
     * algorand.asset.bulkOptIn("ACCOUNTADDRESS", [12345n, 67890n])
     * // With configuration
     * algorand.asset.bulkOptIn("ACCOUNTADDRESS", [12345n, 67890n], { maxFee: (1000).microAlgo(), suppressLog: true })
     * ```
     * @returns An array of records matching asset ID to transaction ID of the opt in
     */
    async bulkOptIn(account, assetIds, options) {
        const results = [];
        for (const assetGroup of chunkArray(assetIds, MAX_TRANSACTION_GROUP_SIZE)) {
            const composer = this._newGroup();
            for (const assetId of assetGroup) {
                composer.addAssetOptIn({
                    ...options,
                    sender: typeof account === 'string' ? account : account.addr,
                    assetId: BigInt(assetId),
                });
            }
            const result = await composer.send(options);
            Config.getLogger(options?.suppressLog).info(`Successfully opted in ${account} for assets ${assetGroup.join(', ')} with transaction IDs ${result.txIds.join(', ')}` +
                `\n  Grouped under ${result.groupId} in round ${result.confirmations?.[0]?.confirmedRound}.`);
            assetGroup.forEach((assetId, index) => {
                results.push({ assetId: BigInt(assetId), transactionId: result.txIds[index] });
            });
        }
        return results;
    }
    /**
     * Opt an account out of a list of Algorand Standard Assets.
     *
     * Transactions will be sent in batches of 16 as transaction groups.
     *
     * @param account The account to opt-in
     * @param assetIds The list of asset IDs to opt-out of
     * @param options Any parameters to control the transaction or execution of the transaction
     * @example Example using AlgorandClient
     * ```typescript
     * // Basic example
     * algorand.asset.bulkOptOut("ACCOUNTADDRESS", [12345n, 67890n])
     * // With configuration
     * algorand.asset.bulkOptOut("ACCOUNTADDRESS", [12345n, 67890n], { ensureZeroBalance: true, maxFee: (1000).microAlgo(), suppressLog: true })
     * ```
     * @returns An array of records matching asset ID to transaction ID of the opt in
     */
    async bulkOptOut(account, assetIds, options) {
        const results = [];
        const sender = typeof account === 'string' ? account : account.addr;
        for (const assetGroup of chunkArray(assetIds, MAX_TRANSACTION_GROUP_SIZE)) {
            const composer = this._newGroup();
            const notOptedInAssetIds = [];
            const nonZeroBalanceAssetIds = [];
            for (const assetId of assetGroup) {
                if (options?.ensureZeroBalance !== false) {
                    try {
                        const accountAssetInfo = await this.getAccountInformation(sender, assetId);
                        if (accountAssetInfo.balance !== 0n) {
                            nonZeroBalanceAssetIds.push(BigInt(assetId));
                        }
                    }
                    catch {
                        notOptedInAssetIds.push(BigInt(assetId));
                    }
                }
            }
            if (notOptedInAssetIds.length > 0 || nonZeroBalanceAssetIds.length > 0) {
                throw new Error(`Account ${sender}${notOptedInAssetIds.length > 0 ? ` is not opted-in to Asset${notOptedInAssetIds.length > 1 ? 's' : ''} ${notOptedInAssetIds.join(', ')}` : ''}${nonZeroBalanceAssetIds.length > 0
                    ? ` has non-zero balance for Asset${nonZeroBalanceAssetIds.length > 1 ? 's' : ''} ${nonZeroBalanceAssetIds.join(', ')}`
                    : ''}; can't opt-out.`);
            }
            for (const assetId of assetGroup) {
                composer.addAssetOptOut({
                    ...options,
                    creator: (await this.getById(BigInt(assetId))).creator,
                    sender,
                    assetId: BigInt(assetId),
                });
            }
            const result = await composer.send(options);
            Config.getLogger(options?.suppressLog).info(`Successfully opted ${account} out of assets ${assetGroup.join(', ')} with transaction IDs ${result.txIds.join(', ')}` +
                `\n  Grouped under ${result.groupId} in round ${result.confirmations?.[0]?.confirmedRound}.`);
            assetGroup.forEach((assetId, index) => {
                results.push({ assetId: BigInt(assetId), transactionId: result.txIds[index] });
            });
        }
        return results;
    }
}

export { AssetManager };
//# sourceMappingURL=asset-manager.mjs.map
