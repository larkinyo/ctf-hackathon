{"version":3,"file":"account-manager.mjs","sources":["../../src/types/account-manager.ts"],"sourcesContent":["import algosdk from 'algosdk'\nimport { Config } from '../config'\nimport { calculateFundAmount, memoize } from '../util'\nimport { AccountInformation, DISPENSER_ACCOUNT, MultisigAccount, SigningAccount, TransactionSignerAccount } from './account'\nimport { AlgoAmount } from './amount'\nimport { ClientManager } from './client-manager'\nimport AlgoKitComposer, { CommonTransactionParams } from './composer'\nimport { TestNetDispenserApiClient } from './dispenser-client'\nimport { KmdAccountManager } from './kmd-account-manager'\nimport { SendParams, SendSingleTransactionResult } from './transaction'\nimport LogicSigAccount = algosdk.LogicSigAccount\nimport Account = algosdk.Account\nimport TransactionSigner = algosdk.TransactionSigner\nimport AccountInformationModel = algosdk.modelsv2.Account\n\n/** Result from performing an ensureFunded call. */\nexport interface EnsureFundedResult {\n  /** The transaction ID of the transaction that funded the account. */\n  transactionId: string\n  /** The amount that was sent to the account. */\n  amountFunded: AlgoAmount\n}\n\n/**\n * Returns a `TransactionSigner` for the given account that can sign a transaction.\n * This function has memoization, so will return the same transaction signer for a given account.\n * @param account An account that can sign a transaction\n * @returns A transaction signer\n */\nexport const getAccountTransactionSigner = memoize(function (\n  account: TransactionSignerAccount | Account | SigningAccount | LogicSigAccount | MultisigAccount,\n): TransactionSigner {\n  return 'signer' in account\n    ? account.signer\n    : 'lsig' in account\n      ? algosdk.makeLogicSigAccountTransactionSigner(account)\n      : algosdk.makeBasicAccountTransactionSigner(account)\n})\n\n/** Creates and keeps track of signing accounts that can sign transactions for a sending address. */\nexport class AccountManager {\n  private _clientManager: ClientManager\n  private _kmdAccountManager: KmdAccountManager\n  private _accounts: { [address: string]: TransactionSignerAccount } = {}\n  private _defaultSigner?: algosdk.TransactionSigner\n\n  /**\n   * Create a new account manager.\n   * @param clientManager The ClientManager client to use for algod and kmd clients\n   * @example Create a new account manager\n   * ```typescript\n   * const accountManager = new AccountManager(clientManager)\n   * ```\n   */\n  constructor(clientManager: ClientManager) {\n    this._clientManager = clientManager\n    this._kmdAccountManager = new KmdAccountManager(clientManager)\n  }\n\n  private _getComposer(getSuggestedParams?: () => Promise<algosdk.SuggestedParams>) {\n    return new AlgoKitComposer({\n      algod: this._clientManager.algod,\n      getSigner: this.getSigner.bind(this),\n      getSuggestedParams: getSuggestedParams ?? (() => this._clientManager.algod.getTransactionParams().do()),\n    })\n  }\n\n  /** KMD account manager that allows you to easily get and create accounts using KMD. */\n  public get kmd() {\n    return this._kmdAccountManager\n  }\n\n  /**\n   * Sets the default signer to use if no other signer is specified.\n   *\n   * If this isn't set an a transaction needs signing for a given sender\n   * then an error will be thrown from `getSigner` / `getAccount`.\n   * @param signer The signer to use, either a `TransactionSigner` or a `TransactionSignerAccount`\n   * @example\n   * ```typescript\n   * const signer = accountManager.random() // Can be anything that returns a `algosdk.TransactionSigner` or `TransactionSignerAccount`\n   * accountManager.setDefaultSigner(signer)\n   *\n   * // When signing a transaction, if there is no signer registered for the sender then the default signer will be used\n   * const signer = accountManager.getSigner(\"{SENDERADDRESS}\")\n   * ```\n   * @returns The `AccountManager` so method calls can be chained\n   */\n  public setDefaultSigner(signer: algosdk.TransactionSigner | TransactionSignerAccount): AccountManager {\n    this._defaultSigner = 'signer' in signer ? signer.signer : signer\n    return this\n  }\n\n  /**\n   * Records the given account (that can sign) against the address of the provided account for later\n   * retrieval and returns a `TransactionSignerAccount` along with the original account in an `account` property.\n   */\n  private signerAccount<T extends TransactionSignerAccount | Account | SigningAccount | LogicSigAccount | MultisigAccount>(\n    account: T,\n  ): TransactionSignerAccount & { account: T } {\n    const acc = {\n      addr: 'addr' in account ? account.addr : account.address(),\n      signer: getAccountTransactionSigner(account),\n    }\n    this._accounts[acc.addr] = acc\n    return { ...acc, account }\n  }\n\n  /**\n   * Tracks the given account for later signing.\n   *\n   * Note: If you are generating accounts via the various methods on `AccountManager`\n   * (like `random`, `fromMnemonic`, `logicsig`, etc.) then they automatically get tracked.\n   * @param account The account to register, which can be a `TransactionSignerAccount` or\n   *  a `algosdk.Account`, `algosdk.LogicSigAccount`, `SigningAccount` or `MultisigAccount`\n   * @example\n   * ```typescript\n   * const accountManager = new AccountManager(clientManager)\n   *  .setSignerFromAccount(algosdk.generateAccount())\n   *  .setSignerFromAccount(new algosdk.LogicSigAccount(program, args))\n   *  .setSignerFromAccount(new SigningAccount(mnemonic, sender))\n   *  .setSignerFromAccount(new MultisigAccount({version: 1, threshold: 1, addrs: [\"ADDRESS1...\", \"ADDRESS2...\"]}, [account1, account2]))\n   *  .setSignerFromAccount({addr: \"SENDERADDRESS\", signer: transactionSigner})\n   * ```\n   * @returns The `AccountManager` instance for method chaining\n   */\n  public setSignerFromAccount(account: TransactionSignerAccount | Account | LogicSigAccount | SigningAccount | MultisigAccount) {\n    this.signerAccount(account)\n    return this\n  }\n\n  /**\n   * Tracks the given `algosdk.TransactionSigner` against the given sender address for later signing.\n   * @param sender The sender address to use this signer for\n   * @param signer The `algosdk.TransactionSigner` to sign transactions with for the given sender\n   * @example\n   * ```typescript\n   * const accountManager = new AccountManager(clientManager)\n   *  .setSigner(\"SENDERADDRESS\", transactionSigner)\n   * ```\n   * @returns The `AccountManager` instance for method chaining\n   */\n  public setSigner(sender: string, signer: algosdk.TransactionSigner) {\n    this._accounts[sender] = { addr: sender, signer }\n    return this\n  }\n\n  /**\n   * Takes all registered signers from the given `AccountManager` and adds them to this `AccountManager`.\n   *\n   * This is useful for situations where you have multiple contexts you are building accounts in such as unit tests.\n   * @param anotherAccountManager Another account manager with signers registered\n   * @param overwriteExisting Whether or not to overwrite any signers that have the same sender address with the ones in the other account manager or not (default: true)\n   * @returns The `AccountManager` instance for method chaining\n   */\n  public setSigners(anotherAccountManager: AccountManager, overwriteExisting = true) {\n    this._accounts = overwriteExisting\n      ? { ...this._accounts, ...anotherAccountManager._accounts }\n      : { ...anotherAccountManager._accounts, ...this._accounts }\n    return\n  }\n\n  /**\n   * Returns the `TransactionSigner` for the given sender address, ready to sign a transaction for that sender.\n   *\n   * If no signer has been registered for that address then the default signer is used if registered and\n   * if not then an error is thrown.\n   *\n   * @param sender The sender address\n   * @example\n   * ```typescript\n   * const signer = accountManager.getSigner(\"SENDERADDRESS\")\n   * ```\n   * @returns The `TransactionSigner` or throws an error if not found and no default signer is set\n   */\n  public getSigner(sender: string): algosdk.TransactionSigner {\n    const signer = this._accounts[sender]?.signer ?? this._defaultSigner\n    if (!signer) throw new Error(`No signer found for address ${sender}`)\n    return signer\n  }\n\n  /**\n   * Returns the `TransactionSignerAccount` for the given sender address.\n   *\n   * If no signer has been registered for that address then an error is thrown.\n   * @param sender The sender address\n   * @example\n   * ```typescript\n   * const sender = accountManager.random().addr\n   * // ...\n   * // Returns the `TransactionSignerAccount` for `sender` that has previously been registered\n   * const account = accountManager.getAccount(sender)\n   * ```\n   * @returns The `TransactionSignerAccount` or throws an error if not found\n   */\n  public getAccount(sender: string): TransactionSignerAccount {\n    const account = this._accounts[sender]\n    if (!account) throw new Error(`No signer found for address ${sender}`)\n    return account\n  }\n\n  /**\n   * Returns the given sender account's current status, balance and spendable amounts.\n   *\n   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)\n   * @example\n   * ```typescript\n   * const address = \"XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA\";\n   * const accountInfo = await accountManager.getInformation(address);\n   * ```\n   *\n   * @param sender The account / address to look up\n   * @returns The account information\n   */\n  public async getInformation(sender: string | TransactionSignerAccount): Promise<AccountInformation> {\n    const account = AccountInformationModel.from_obj_for_encoding(\n      await this._clientManager.algod.accountInformation(typeof sender === 'string' ? sender : sender.addr).do(),\n    )\n\n    return {\n      ...account,\n      // None of these can practically overflow 2^53\n      balance: AlgoAmount.MicroAlgo(Number(account.amount)),\n      amountWithoutPendingRewards: AlgoAmount.MicroAlgo(Number(account.amountWithoutPendingRewards)),\n      minBalance: AlgoAmount.MicroAlgo(Number(account.minBalance)),\n      pendingRewards: AlgoAmount.MicroAlgo(Number(account.pendingRewards)),\n      rewards: AlgoAmount.MicroAlgo(Number(account.rewards)),\n      validAsOfRound: BigInt(account.round),\n      totalAppsOptedIn: Number(account.totalAppsOptedIn),\n      totalAssetsOptedIn: Number(account.totalAssetsOptedIn),\n      totalCreatedApps: Number(account.totalCreatedApps),\n      totalCreatedAssets: Number(account.totalCreatedAssets),\n      appsTotalExtraPages: account.appsTotalExtraPages ? Number(account.appsTotalExtraPages) : undefined,\n      rewardBase: account.rewardBase ? Number(account.rewardBase) : undefined,\n      totalBoxBytes: account.totalBoxBytes ? Number(account.totalBoxBytes) : undefined,\n      totalBoxes: account.totalBoxes ? Number(account.totalBoxes) : undefined,\n    }\n  }\n\n  /**\n   * Tracks and returns an Algorand account with secret key loaded (i.e. that can sign transactions) by taking the mnemonic secret.\n   *\n   * @example\n   * ```typescript\n   * const account = accountManager.fromMnemonic(\"mnemonic secret ...\")\n   * const rekeyedAccount = accountManager.fromMnemonic(\"mnemonic secret ...\", \"SENDERADDRESS...\")\n   * ```\n   * @param mnemonicSecret The mnemonic secret representing the private key of an account; **Note: Be careful how the mnemonic is handled**,\n   *  never commit it into source control and ideally load it from the environment (ideally via a secret storage service) rather than the file system.\n   * @param sender The optional sender address to use this signer for (aka a rekeyed account)\n   * @returns The account\n   */\n  public fromMnemonic(mnemonicSecret: string, sender?: string) {\n    const account = algosdk.mnemonicToSecretKey(mnemonicSecret)\n    return this.signerAccount(new SigningAccount(account, sender))\n  }\n\n  /**\n   * Tracks and returns an Algorand account that is a rekeyed version of the given account to a new sender.\n   *\n   * @example\n   * ```typescript\n   * const account = account.fromMnemonic(\"mnemonic secret ...\")\n   * const rekeyedAccount = accountManager.rekeyed(account, \"SENDERADDRESS...\")\n   * ```\n   * @param account The account to use as the signer for this new rekeyed account\n   * @param sender The sender address to use as the new sender\n   * @returns The account\n   */\n  public rekeyed(sender: string, account: TransactionSignerAccount) {\n    return this.signerAccount({ addr: sender, signer: account.signer })\n  }\n\n  /**\n   * Tracks and returns an Algorand account with private key loaded by convention from environment variables based on the given name identifier.\n   *\n   * Note: This function expects to run in a Node.js environment.\n   *\n   * ## Convention:\n   * * **Non-LocalNet:** will load process.env['\\{NAME\\}_MNEMONIC'] as a mnemonic secret; **Note: Be careful how the mnemonic is handled**,\n   *  never commit it into source control and ideally load it via a secret storage service rather than the file system.\n   *   If process.env['\\{NAME\\}_SENDER'] is defined then it will use that for the sender address (i.e. to support rekeyed accounts)\n   * * **LocalNet:** will load the account from a KMD wallet called \\{NAME\\} and if that wallet doesn't exist it will create it and fund the account for you\n   *\n   * This allows you to write code that will work seamlessly in production and local development (LocalNet) without manual config locally (including when you reset the LocalNet).\n   *\n   * @example Default\n   *\n   * If you have a mnemonic secret loaded into `process.env.MY_ACCOUNT_MNEMONIC` then you can call the following to get that private key loaded into an account object:\n   * ```typescript\n   * const account = await accountManager.fromEnvironment('MY_ACCOUNT')\n   * ```\n   *\n   * If that code runs against LocalNet then a wallet called `MY_ACCOUNT` will automatically be created with an account that is automatically funded with 1000 (default) ALGO from the default LocalNet dispenser.\n   * If not running against LocalNet then it will use proces.env.MY_ACCOUNT_MNEMONIC as the private key and (if present) process.env.MY_ACCOUNT_SENDER as the sender address.\n   *\n   * @param name The name identifier of the account\n   * @param fundWith The optional amount to fund the account with when it gets created (when targeting LocalNet), if not specified then 1000 ALGO will be funded from the dispenser account\n   * @returns The account\n   */\n  public async fromEnvironment(name: string, fundWith?: AlgoAmount) {\n    if (!process || !process.env) {\n      throw new Error('Attempt to get account with private key from a non Node.js context; this is not supported!')\n    }\n\n    const accountMnemonic = process.env[`${name.toUpperCase()}_MNEMONIC`]\n    const sender = process.env[`${name.toUpperCase()}_SENDER`]\n\n    if (accountMnemonic) {\n      const signer = algosdk.mnemonicToSecretKey(accountMnemonic)\n      return this.signerAccount(new SigningAccount(signer, sender))\n    }\n\n    if (await this._clientManager.isLocalNet()) {\n      const account = await this._kmdAccountManager.getOrCreateWalletAccount(name, fundWith)\n      return this.signerAccount(account.account)\n    }\n\n    throw new Error(`Missing environment variable ${name.toUpperCase()}_MNEMONIC when looking for account ${name}`)\n  }\n\n  /**\n   * Tracks and returns an Algorand account with private key loaded from the given KMD wallet (identified by name).\n   *\n   * @param name The name of the wallet to retrieve an account from\n   * @param predicate An optional filter to use to find the account (otherwise it will return a random account from the wallet)\n   * @param sender The optional sender address to use this signer for (aka a rekeyed account)\n   * @example Get default funded account in a LocalNet\n   *\n   * ```typescript\n   * const defaultDispenserAccount = await account.fromKmd('unencrypted-default-wallet',\n   *   a => a.status !== 'Offline' && a.amount > 1_000_000_000\n   * )\n   * ```\n   * @returns The account\n   */\n  public async fromKmd(\n    name: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    predicate?: (account: Record<string, any>) => boolean,\n    sender?: string,\n  ) {\n    const account = await this._kmdAccountManager.getWalletAccount(name, predicate, sender)\n    if (!account) throw new Error(`Unable to find KMD account ${name}${predicate ? ' with predicate' : ''}`)\n    return this.signerAccount(account.account)\n  }\n\n  /**\n   * Tracks and returns an account that supports partial or full multisig signing.\n   *\n   * @example\n   * ```typescript\n   * const account = accountManager.multisig({version: 1, threshold: 1, addrs: [\"ADDRESS1...\", \"ADDRESS2...\"]},\n   *  [(await accountManager.fromEnvironment('ACCOUNT1')).account])\n   * ```\n   * @param multisigParams The parameters that define the multisig account\n   * @param signingAccounts The signers that are currently present\n   * @returns A multisig account wrapper\n   */\n  public multisig(multisigParams: algosdk.MultisigMetadata, signingAccounts: (algosdk.Account | SigningAccount)[]) {\n    return this.signerAccount(new MultisigAccount(multisigParams, signingAccounts))\n  }\n\n  /**\n   * Tracks and returns an account that represents a logic signature.\n   *\n   * @example\n   * ```typescript\n   * const account = account.logicsig(program, [new Uint8Array(3, ...)])\n   * ```\n   * @param program The bytes that make up the compiled logic signature\n   * @param args The (binary) arguments to pass into the logic signature\n   * @returns A logic signature account wrapper\n   */\n  public logicsig(program: Uint8Array, args?: Array<Uint8Array>) {\n    return this.signerAccount(new LogicSigAccount(program, args))\n  }\n\n  /**\n   * Tracks and returns a new, random Algorand account with secret key loaded.\n   *\n   * @example\n   * ```typescript\n   * const account = account.random()\n   * ```\n   * @returns The account\n   */\n  public random() {\n    return this.signerAccount(algosdk.generateAccount())\n  }\n\n  /**\n   * Returns an account (with private key loaded) that can act as a dispenser from\n   * environment variables, or against default LocalNet if no environment variables present.\n   *\n   * Note: requires a Node.js environment to execute.\n   *\n   * If present, it will load the account mnemonic stored in process.env.DISPENSER_MNEMONIC and optionally\n   * process.env.DISPENSER_SENDER if it's a rekeyed account.\n   *\n   * @example\n   * ```typescript\n   * const account = await account.dispenserFromEnvironment()\n   * ```\n   *\n   * @returns The account\n   */\n  public async dispenserFromEnvironment() {\n    if (!process || !process.env) {\n      throw new Error('Attempt to get dispenser from environment from a non Node.js context; this is not supported!')\n    }\n\n    return process.env[`${DISPENSER_ACCOUNT.toUpperCase()}_MNEMONIC`]\n      ? await this.fromEnvironment(DISPENSER_ACCOUNT)\n      : await this.localNetDispenser()\n  }\n\n  /**\n   * Returns an Algorand account with private key loaded for the default LocalNet dispenser account (that can be used to fund other accounts).\n   *\n   * @example\n   * ```typescript\n   * const account = await account.localNetDispenser()\n   * ```\n   * @returns The account\n   */\n  public async localNetDispenser() {\n    const dispenser = await this._kmdAccountManager.getLocalNetDispenserAccount()\n    return this.signerAccount(dispenser.account)\n  }\n\n  /**\n   * Rekey an account to a new address.\n   *\n   * **Note:** Please be careful with this function and be sure to read the [official rekey guidance](https://developer.algorand.org/docs/get-details/accounts/rekey/).\n   *\n   * @param account The account to rekey\n   * @param rekeyTo The account address or signing account of the account that will be used to authorise transactions for the rekeyed account going forward.\n   *  If a signing account is provided that will now be tracked as the signer for `account` in this `AccountManager`\n   * @param options Any parameters to control the transaction or execution of the transaction\n   *\n   * @example Basic example (with string addresses)\n   * ```typescript\n   * await algorand.account.rekeyAccount({account: \"ACCOUNTADDRESS\", rekeyTo: \"NEWADDRESS\"})\n   * ```\n   * @example Basic example (with signer accounts)\n   * ```typescript\n   * await algorand.account.rekeyAccount({account: account1, rekeyTo: newSignerAccount})\n   * ```\n   * @example Advanced example\n   * ```typescript\n   * await algorand.account.rekeyAccount({\n   *   account: \"ACCOUNTADDRESS\",\n   *   rekeyTo: \"NEWADDRESS\",\n   *   lease: 'lease',\n   *   note: 'note',\n   *   firstValidRound: 1000n,\n   *   validityWindow: 10,\n   *   extraFee: (1000).microAlgo(),\n   *   staticFee: (1000).microAlgo(),\n   *   // Max fee doesn't make sense with extraFee AND staticFee\n   *   //  already specified, but here for completeness\n   *   maxFee: (3000).microAlgo(),\n   *   maxRoundsToWaitForConfirmation: 5,\n   *   suppressLog: true,\n   * })\n   * ```\n   * @returns The result of the transaction and the transaction that was sent\n   */\n  async rekeyAccount(\n    account: string | TransactionSignerAccount,\n    rekeyTo: string | TransactionSignerAccount,\n    options?: Omit<CommonTransactionParams, 'sender'> & SendParams,\n  ): Promise<SendSingleTransactionResult> {\n    const result = await this._getComposer()\n      .addPayment({\n        ...options,\n        sender: typeof account === 'string' ? account : account.addr,\n        receiver: typeof account === 'string' ? account : account.addr,\n        amount: AlgoAmount.MicroAlgo(0),\n        rekeyTo: typeof rekeyTo === 'string' ? rekeyTo : rekeyTo.addr,\n      })\n      .send(options)\n\n    // If the rekey is a signing account set it as the signer for this account\n    if (typeof rekeyTo !== 'string') {\n      this.rekeyed(typeof account === 'string' ? account : account.addr, rekeyTo)\n    }\n\n    Config.getLogger(options?.suppressLog).info(`Rekeyed ${account} to ${rekeyTo} via transaction ${result.txIds.at(-1)}`)\n\n    return { ...result, transaction: result.transactions.at(-1)!, confirmation: result.confirmations.at(-1)! }\n  }\n\n  private async _getEnsureFundedAmount(sender: string, minSpendingBalance: AlgoAmount, minFundingIncrement?: AlgoAmount) {\n    const accountInfo = await this.getInformation(sender)\n    const currentSpendingBalance = accountInfo.balance.microAlgo - accountInfo.minBalance.microAlgo\n\n    const amountFunded = calculateFundAmount(minSpendingBalance.microAlgo, currentSpendingBalance, minFundingIncrement?.microAlgo ?? 0n)\n\n    return amountFunded === null ? undefined : AlgoAmount.MicroAlgo(amountFunded)\n  }\n\n  /**\n   * Funds a given account using a dispenser account as a funding source such that\n   * the given account has a certain amount of Algo free to spend (accounting for\n   * Algo locked in minimum balance requirement).\n   *\n   * https://developer.algorand.org/docs/get-details/accounts/#minimum-balance\n   *\n   * @param accountToFund The account to fund\n   * @param dispenserAccount The account to use as a dispenser funding source\n   * @param minSpendingBalance The minimum balance of Algo that the account should have available to spend (i.e. on top of minimum balance requirement)\n   * @param options Optional parameters to control the funding increment, transaction or execution of the transaction\n   * @example Example using AlgorandClient\n   * ```typescript\n   * // Basic example\n   * await algorand.account.ensureFunded(\"ACCOUNTADDRESS\", \"DISPENSERADDRESS\", algokit.algo(1))\n   * // With configuration\n   * await algorand.account.ensureFunded(\"ACCOUNTADDRESS\", \"DISPENSERADDRESS\", algokit.algo(1),\n   *  { minFundingIncrement: algokit.algo(2), fee: (1000).microAlgo(), suppressLog: true }\n   * )\n   * ```\n   * @returns\n   * - The result of executing the dispensing transaction and the `amountFunded` if funds were needed.\n   * - `undefined` if no funds were needed.\n   */\n  async ensureFunded(\n    accountToFund: string | TransactionSignerAccount,\n    dispenserAccount: string | TransactionSignerAccount,\n    minSpendingBalance: AlgoAmount,\n    options?: {\n      minFundingIncrement?: AlgoAmount\n    } & SendParams &\n      Omit<CommonTransactionParams, 'sender'>,\n  ): Promise<(SendSingleTransactionResult & EnsureFundedResult) | undefined> {\n    const addressToFund = typeof accountToFund === 'string' ? accountToFund : accountToFund.addr\n\n    const amountFunded = await this._getEnsureFundedAmount(addressToFund, minSpendingBalance, options?.minFundingIncrement)\n    if (!amountFunded) return undefined\n\n    const result = await this._getComposer()\n      .addPayment({\n        ...options,\n        sender: typeof dispenserAccount === 'string' ? dispenserAccount : dispenserAccount.addr,\n        receiver: addressToFund,\n        amount: amountFunded,\n      })\n      .send(options)\n\n    return {\n      ...result,\n      transaction: result.transactions[0],\n      confirmation: result.confirmations[0],\n      transactionId: result.txIds[0],\n      amountFunded: amountFunded,\n    }\n  }\n\n  /**\n   * Funds a given account using a dispenser account retrieved from the environment,\n   * per the `dispenserFromEnvironment` method, as a funding source such that\n   * the given account has a certain amount of Algo free to spend (accounting for\n   * Algo locked in minimum balance requirement).\n   *\n   * **Note:** requires a Node.js environment to execute.\n   *\n   * The dispenser account is retrieved from the account mnemonic stored in\n   * process.env.DISPENSER_MNEMONIC and optionally process.env.DISPENSER_SENDER\n   * if it's a rekeyed account, or against default LocalNet if no environment variables present.\n   *\n   * https://developer.algorand.org/docs/get-details/accounts/#minimum-balance\n   *\n   * @param accountToFund The account to fund\n   * @param minSpendingBalance The minimum balance of Algo that the account should have available to spend (i.e. on top of minimum balance requirement)\n   * @param options Optional parameters to control the funding increment, transaction or execution of the transaction\n   * @example Example using AlgorandClient\n   * ```typescript\n   * // Basic example\n   * await algorand.account.ensureFundedFromEnvironment(\"ACCOUNTADDRESS\", algokit.algo(1))\n   * // With configuration\n   * await algorand.account.ensureFundedFromEnvironment(\"ACCOUNTADDRESS\", algokit.algo(1),\n   *  { minFundingIncrement: algokit.algo(2), fee: (1000).microAlgo(), suppressLog: true }\n   * )\n   * ```\n   * @returns\n   * - The result of executing the dispensing transaction and the `amountFunded` if funds were needed.\n   * - `undefined` if no funds were needed.\n   */\n  async ensureFundedFromEnvironment(\n    accountToFund: string | TransactionSignerAccount,\n    minSpendingBalance: AlgoAmount,\n    options?: {\n      minFundingIncrement?: AlgoAmount\n    } & SendParams &\n      Omit<CommonTransactionParams, 'sender'>,\n  ): Promise<(SendSingleTransactionResult & EnsureFundedResult) | undefined> {\n    const addressToFund = typeof accountToFund === 'string' ? accountToFund : accountToFund.addr\n    const dispenserAccount = await this.dispenserFromEnvironment()\n\n    const amountFunded = await this._getEnsureFundedAmount(addressToFund, minSpendingBalance, options?.minFundingIncrement)\n    if (!amountFunded) return undefined\n\n    const result = await this._getComposer()\n      .addPayment({\n        ...options,\n        sender: dispenserAccount.addr,\n        receiver: addressToFund,\n        amount: amountFunded,\n      })\n      .send(options)\n\n    return {\n      ...result,\n      transaction: result.transactions[0],\n      confirmation: result.confirmations[0],\n      transactionId: result.txIds[0],\n      amountFunded: amountFunded,\n    }\n  }\n\n  /**\n   * Funds a given account using the TestNet Dispenser API as a funding source such that\n   * the account has a certain amount of Algo free to spend (accounting for Algo locked\n   * in minimum balance requirement).\n   *\n   * https://developer.algorand.org/docs/get-details/accounts/#minimum-balance\n   *\n   * @param accountToFund The account to fund\n   * @param dispenserClient The TestNet dispenser funding client\n   * @param minSpendingBalance The minimum balance of Algo that the account should have available to spend (i.e. on top of minimum balance requirement)\n   * @param options Optional parameters to control the funding increment, transaction or execution of the transaction\n   * @example Example using AlgorandClient\n   * ```typescript\n   * // Basic example\n   * await algorand.account.ensureFundedUsingDispenserAPI(\"ACCOUNTADDRESS\", algorand.client.getTestNetDispenserFromEnvironment(), algokit.algo(1))\n   * // With configuration\n   * await algorand.account.ensureFundedUsingDispenserAPI(\"ACCOUNTADDRESS\", algorand.client.getTestNetDispenserFromEnvironment(), algokit.algo(1),\n   *  { minFundingIncrement: algokit.algo(2) }\n   * )\n   * ```\n   * @returns\n   * - The result of executing the dispensing transaction and the `amountFunded` if funds were needed.\n   * - `undefined` if no funds were needed.\n   */\n  async ensureFundedFromTestNetDispenserApi(\n    accountToFund: string | TransactionSignerAccount,\n    dispenserClient: TestNetDispenserApiClient,\n    minSpendingBalance: AlgoAmount,\n    options: {\n      minFundingIncrement?: AlgoAmount\n    },\n  ): Promise<EnsureFundedResult | undefined> {\n    if (!(await this._clientManager.isTestNet())) {\n      throw new Error('Attempt to fund using TestNet dispenser API on non TestNet network.')\n    }\n\n    const addressToFund = typeof accountToFund === 'string' ? accountToFund : accountToFund.addr\n\n    const amountFunded = await this._getEnsureFundedAmount(addressToFund, minSpendingBalance, options?.minFundingIncrement)\n    if (!amountFunded) return undefined\n\n    const result = await dispenserClient.fund(addressToFund, amountFunded.microAlgo)\n    return {\n      amountFunded: AlgoAmount.MicroAlgo(result.amount),\n      transactionId: result.txId,\n    }\n  }\n}\n"],"names":[],"mappings":"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"}