import algosdk from 'algosdk';
import { TransactionSignerAccount } from './account';
import { AlgoAmount } from './amount';
import { AppManager, BoxIdentifier, BoxReference } from './app-manager';
import { Expand } from './expand';
import { Arc2TransactionNote, SendAtomicTransactionComposerResults, SendParams } from './transaction';
import Transaction = algosdk.Transaction;
import TransactionSigner = algosdk.TransactionSigner;
import TransactionWithSigner = algosdk.TransactionWithSigner;
import SimulateResponse = algosdk.modelsv2.SimulateResponse;
import modelsv2 = algosdk.modelsv2;
export declare const MAX_TRANSACTION_GROUP_SIZE = 16;
/** Options to control a simulate request */
export type SimulateOptions = Expand<Omit<ConstructorParameters<typeof modelsv2.SimulateRequest>[0], 'txnGroups'>>;
/** Common parameters for defining a transaction. */
export type CommonTransactionParams = {
    /** The address of the account sending the transaction. */
    sender: string;
    /** The function used to sign transaction(s); if not specified then
     *  an attempt will be made to find a registered signer for the
     *  given `sender` or use a default signer (if configured).
     */
    signer?: algosdk.TransactionSigner | TransactionSignerAccount;
    /** Change the signing key of the sender to the given address.
     *
     * **Warning:** Please be careful with this parameter and be sure to read the [official rekey guidance](https://developer.algorand.org/docs/get-details/accounts/rekey/).
     */
    rekeyTo?: string;
    /** Note to attach to the transaction. Max of 1000 bytes. */
    note?: Uint8Array | string;
    /** Prevent multiple transactions with the same lease being included within the validity window.
     *
     * A [lease](https://developer.algorand.org/articles/leased-transactions-securing-advanced-smart-contract-design/)
     *  enforces a mutually exclusive transaction (useful to prevent double-posting and other scenarios).
     */
    lease?: Uint8Array | string;
    /** The static transaction fee. In most cases you want to use `extraFee` unless setting the fee to 0 to be covered by another transaction. */
    staticFee?: AlgoAmount;
    /** The fee to pay IN ADDITION to the suggested fee. Useful for covering inner transaction fees. */
    extraFee?: AlgoAmount;
    /** Throw an error if the fee for the transaction is more than this amount; prevents overspending on fees during high congestion periods. */
    maxFee?: AlgoAmount;
    /** How many rounds the transaction should be valid for, if not specified then the registered default validity window will be used. */
    validityWindow?: number;
    /**
     * Set the first round this transaction is valid.
     * If left undefined, the value from algod will be used.
     *
     * We recommend you only set this when you intentionally want this to be some time in the future.
     */
    firstValidRound?: bigint;
    /** The last round this transaction is valid. It is recommended to use `validityWindow` instead. */
    lastValidRound?: bigint;
};
/** Parameters to define a payment transaction. */
export type PaymentParams = CommonTransactionParams & {
    /** The address of the account that will receive the Algo */
    receiver: string;
    /** Amount to send */
    amount: AlgoAmount;
    /** If given, close the sender account and send the remaining balance to this address
     *
     * *Warning:* Be careful with this parameter as it can lead to loss of funds if not used correctly.
     */
    closeRemainderTo?: string;
};
/** Parameters to define an asset create transaction.
 *
 * The account that sends this transaction will automatically be opted in to the asset and will hold all units after creation.
 */
export type AssetCreateParams = CommonTransactionParams & {
    /** The total amount of the smallest divisible (decimal) unit to create.
     *
     * For example, if `decimals` is, say, 2, then for every 100 `total` there would be 1 whole unit.
     *
     * This field can only be specified upon asset creation.
     */
    total: bigint;
    /** The amount of decimal places the asset should have.
     *
     * If unspecified then the asset will be in whole units (i.e. `0`).
     *
     * * If 0, the asset is not divisible;
     * * If 1, the base unit of the asset is in tenths;
     * * If 2, the base unit of the asset is in hundredths;
     * * If 3, the base unit of the asset is in thousandths;
     * * and so on up to 19 decimal places.
     *
     * This field can only be specified upon asset creation.
     */
    decimals?: number;
    /** The optional name of the asset.
     *
     * Max size is 32 bytes.
     *
     * This field can only be specified upon asset creation.
     */
    assetName?: string;
    /** The optional name of the unit of this asset (e.g. ticker name).
     *
     * Max size is 8 bytes.
     *
     * This field can only be specified upon asset creation.
     */
    unitName?: string;
    /** Specifies an optional URL where more information about the asset can be retrieved (e.g. metadata).
     *
     * Max size is 96 bytes.
     *
     * This field can only be specified upon asset creation.
     */
    url?: string;
    /** 32-byte hash of some metadata that is relevant to your asset and/or asset holders.
     *
     * The format of this metadata is up to the application.
     *
     * This field can only be specified upon asset creation.
     */
    metadataHash?: string | Uint8Array;
    /** Whether the asset is frozen by default for all accounts.
     * Defaults to `false`.
     *
     * If `true` then for anyone apart from the creator to hold the
     * asset it needs to be unfrozen per account using an asset freeze
     * transaction from the `freeze` account, which must be set on creation.
     *
     * This field can only be specified upon asset creation.
     */
    defaultFrozen?: boolean;
    /** The address of the optional account that can manage the configuration of the asset and destroy it.
     *
     * The configuration fields it can change are `manager`, `reserve`, `clawback`, and `freeze`.
     *
     * If not set (`undefined` or `""`) at asset creation or subsequently set to empty by the `manager` the asset becomes permanently immutable.
     */
    manager?: string;
    /**
     * The address of the optional account that holds the reserve (uncirculated supply) units of the asset.
     *
     * This address has no specific authority in the protocol itself and is informational only.
     *
     * Some standards like [ARC-19](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0019.md)
     * rely on this field to hold meaningful data.
     *
     * It can be used in the case where you want to signal to holders of your asset that the uncirculated units
     * of the asset reside in an account that is different from the default creator account.
     *
     * If not set (`undefined` or `""`) at asset creation or subsequently set to empty by the manager the field is permanently empty.
     */
    reserve?: string;
    /**
     * The address of the optional account that can be used to freeze or unfreeze holdings of this asset for any account.
     *
     * If empty, freezing is not permitted.
     *
     * If not set (`undefined` or `""`) at asset creation or subsequently set to empty by the manager the field is permanently empty.
     */
    freeze?: string;
    /**
     * The address of the optional account that can clawback holdings of this asset from any account.
     *
     * **This field should be used with caution** as the clawback account has the ability to **unconditionally take assets from any account**.
     *
     * If empty, clawback is not permitted.
     *
     * If not set (`undefined` or `""`) at asset creation or subsequently set to empty by the manager the field is permanently empty.
     */
    clawback?: string;
};
/** Parameters to define an asset reconfiguration transaction.
 *
 * **Note:** The manager, reserve, freeze, and clawback addresses
 * are immutably empty if they are not set. If manager is not set then
 * all fields are immutable from that point forward.
 */
export type AssetConfigParams = CommonTransactionParams & {
    /** ID of the asset to reconfigure */
    assetId: bigint;
    /** The address of the optional account that can manage the configuration of the asset and destroy it.
     *
     * The configuration fields it can change are `manager`, `reserve`, `clawback`, and `freeze`.
     *
     * If not set (`undefined` or `""`) the asset will become permanently immutable.
     */
    manager: string | undefined;
    /**
     * The address of the optional account that holds the reserve (uncirculated supply) units of the asset.
     *
     * This address has no specific authority in the protocol itself and is informational only.
     *
     * Some standards like [ARC-19](https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0019.md)
     * rely on this field to hold meaningful data.
     *
     * It can be used in the case where you want to signal to holders of your asset that the uncirculated units
     * of the asset reside in an account that is different from the default creator account.
     *
     * If not set (`undefined` or `""`) the field will become permanently empty.
     */
    reserve?: string;
    /**
     * The address of the optional account that can be used to freeze or unfreeze holdings of this asset for any account.
     *
     * If empty, freezing is not permitted.
     *
     * If not set (`undefined` or `""`) the field will become permanently empty.
     */
    freeze?: string;
    /**
     * The address of the optional account that can clawback holdings of this asset from any account.
     *
     * **This field should be used with caution** as the clawback account has the ability to **unconditionally take assets from any account**.
     *
     * If empty, clawback is not permitted.
     *
     * If not set (`undefined` or `""`) the field will become permanently empty.
     */
    clawback?: string;
};
/** Parameters to define an asset freeze transaction. */
export type AssetFreezeParams = CommonTransactionParams & {
    /** The ID of the asset to freeze/unfreeze */
    assetId: bigint;
    /** The address of the account to freeze or unfreeze */
    account: string;
    /** Whether the assets in the account should be frozen */
    frozen: boolean;
};
/** Parameters to define an asset destroy transaction.
 *
 * Created assets can be destroyed only by the asset manager account. All of the assets must be owned by the creator of the asset before the asset can be deleted.
 */
export type AssetDestroyParams = CommonTransactionParams & {
    /** ID of the asset to destroy */
    assetId: bigint;
};
/** Parameters to define an asset transfer transaction. */
export type AssetTransferParams = CommonTransactionParams & {
    /** ID of the asset to transfer. */
    assetId: bigint;
    /** Amount of the asset to transfer (in smallest divisible (decimal) units). */
    amount: bigint;
    /** The address of the account that will receive the asset unit(s). */
    receiver: string;
    /** Optional address of an account to clawback the asset from.
     *
     * Requires the sender to be the clawback account.
     *
     * **Warning:** Be careful with this parameter as it can lead to unexpected loss of funds if not used correctly.
     */
    clawbackTarget?: string;
    /** Optional address of an account to close the asset position to.
     *
     * **Warning:** Be careful with this parameter as it can lead to loss of funds if not used correctly.
     */
    closeAssetTo?: string;
};
/** Parameters to define an asset opt-in transaction. */
export type AssetOptInParams = CommonTransactionParams & {
    /** ID of the asset that will be opted-in to. */
    assetId: bigint;
};
/** Parameters to define an asset opt-out transaction. */
export type AssetOptOutParams = CommonTransactionParams & {
    /** ID of the asset that will be opted-out of. */
    assetId: bigint;
    /**
     * The address of the asset creator account to close the asset
     *   position to (any remaining asset units will be sent to this account).
     */
    creator: string;
};
/** Parameters to define an online key registration transaction. */
export type OnlineKeyRegistrationParams = CommonTransactionParams & {
    /** The root participation public key */
    voteKey: Uint8Array;
    /** The VRF public key */
    selectionKey: Uint8Array;
    /** The first round that the participation key is valid. Not to be confused with the `firstValid` round of the keyreg transaction */
    voteFirst: bigint;
    /** The last round that the participation key is valid. Not to be confused with the `lastValid` round of the keyreg transaction */
    voteLast: bigint;
    /** This is the dilution for the 2-level participation key. It determines the interval (number of rounds) for generating new ephemeral keys */
    voteKeyDilution: bigint;
    /** The 64 byte state proof public key commitment */
    stateProofKey?: Uint8Array;
};
/** Common parameters for defining an application call transaction. */
export type CommonAppCallParams = CommonTransactionParams & {
    /** ID of the application; 0 if the application is being created. */
    appId: bigint;
    /** The [on-complete](https://developer.algorand.org/docs/get-details/dapps/avm/teal/specification/#oncomplete) action of the call; defaults to no-op. */
    onComplete?: algosdk.OnApplicationComplete;
    /** Any [arguments to pass to the smart contract call](https://developer.algorand.org/docs/get-details/dapps/avm/teal/#argument-passing). */
    args?: Uint8Array[];
    /** Any account addresses to add to the [accounts array](https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#reference-arrays). */
    accountReferences?: string[];
    /** The ID of any apps to load to the [foreign apps array](https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#reference-arrays). */
    appReferences?: bigint[];
    /** The ID of any assets to load to the [foreign assets array](https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#reference-arrays). */
    assetReferences?: bigint[];
    /** Any boxes to load to the [boxes array](https://developer.algorand.org/docs/get-details/dapps/smart-contracts/apps/#reference-arrays).
     *
     * Either the name identifier (which will be set against app ID of `0` i.e.
     *  the current app), or a box identifier with the name identifier and app ID.
     */
    boxReferences?: (BoxReference | BoxIdentifier)[];
};
/** Parameters to define an app create transaction */
export type AppCreateParams = Expand<Omit<CommonAppCallParams, 'appId'> & {
    onComplete?: Exclude<algosdk.OnApplicationComplete, algosdk.OnApplicationComplete.ClearStateOC>;
    /** The program to execute for all OnCompletes other than ClearState as raw teal that will be compiled (string) or compiled teal (encoded as a byte array (Uint8Array)). */
    approvalProgram: string | Uint8Array;
    /** The program to execute for ClearState OnComplete as raw teal that will be compiled (string) or compiled teal (encoded as a byte array (Uint8Array)). */
    clearStateProgram: string | Uint8Array;
    /** The state schema for the app. This is immutable once the app is created. */
    schema?: {
        /** The number of integers saved in global state. */
        globalInts: number;
        /** The number of byte slices saved in global state. */
        globalByteSlices: number;
        /** The number of integers saved in local state. */
        localInts: number;
        /** The number of byte slices saved in local state. */
        localByteSlices: number;
    };
    /** Number of extra pages required for the programs.
     * Defaults to the number needed for the programs in this call if not specified.
     * This is immutable once the app is created. */
    extraProgramPages?: number;
}>;
/** Parameters to define an app update transaction */
export type AppUpdateParams = Expand<CommonAppCallParams & {
    onComplete?: algosdk.OnApplicationComplete.UpdateApplicationOC;
    /** The program to execute for all OnCompletes other than ClearState as raw teal (string) or compiled teal (base 64 encoded as a byte array (Uint8Array)) */
    approvalProgram: string | Uint8Array;
    /** The program to execute for ClearState OnComplete as raw teal (string) or compiled teal (base 64 encoded as a byte array (Uint8Array)) */
    clearStateProgram: string | Uint8Array;
}>;
/** Parameters to define an application call transaction. */
export type AppCallParams = CommonAppCallParams & {
    onComplete?: Exclude<algosdk.OnApplicationComplete, algosdk.OnApplicationComplete.UpdateApplicationOC>;
};
/** Common parameters to define an ABI method call transaction. */
export type AppMethodCallParams = CommonAppCallParams & {
    onComplete?: Exclude<algosdk.OnApplicationComplete, algosdk.OnApplicationComplete.UpdateApplicationOC | algosdk.OnApplicationComplete.ClearStateOC>;
};
/** Parameters to define an application delete call transaction. */
export type AppDeleteParams = CommonAppCallParams & {
    onComplete?: algosdk.OnApplicationComplete.DeleteApplicationOC;
};
/** Parameters to define an ABI method call create transaction. */
export type AppCreateMethodCall = AppMethodCall<AppCreateParams>;
/** Parameters to define an ABI method call update transaction. */
export type AppUpdateMethodCall = AppMethodCall<AppUpdateParams>;
/** Parameters to define an ABI method call delete transaction. */
export type AppDeleteMethodCall = AppMethodCall<AppDeleteParams>;
/** Parameters to define an ABI method call transaction. */
export type AppCallMethodCall = AppMethodCall<AppMethodCallParams>;
/** Types that can be used to define a transaction argument for an ABI call transaction. */
export type AppMethodCallTransactionArgument = TransactionWithSigner | Transaction | Promise<Transaction> | AppMethodCall<AppCreateParams> | AppMethodCall<AppUpdateParams> | AppMethodCall<AppMethodCallParams>;
/** Parameters to define an ABI method call. */
export type AppMethodCall<T> = Expand<Omit<T, 'args'>> & {
    /** The ABI method to call */
    method: algosdk.ABIMethod;
    /** Arguments to the ABI method, either:
     * * An ABI value
     * * A transaction with explicit signer
     * * A transaction (where the signer will be automatically assigned)
     * * An unawaited transaction (e.g. from algorand.createTransaction.{transactionType}())
     * * Another method call (via method call params object)
     */
    args?: (algosdk.ABIValue | TransactionWithSigner | Transaction | Promise<Transaction> | AppMethodCall<AppCreateParams> | AppMethodCall<AppUpdateParams> | AppMethodCall<AppMethodCallParams>)[];
};
export type Txn = (PaymentParams & {
    type: 'pay';
}) | (AssetCreateParams & {
    type: 'assetCreate';
}) | (AssetConfigParams & {
    type: 'assetConfig';
}) | (AssetFreezeParams & {
    type: 'assetFreeze';
}) | (AssetDestroyParams & {
    type: 'assetDestroy';
}) | (AssetTransferParams & {
    type: 'assetTransfer';
}) | (AssetOptInParams & {
    type: 'assetOptIn';
}) | (AssetOptOutParams & {
    type: 'assetOptOut';
}) | ((AppCallParams | AppCreateParams | AppUpdateParams) & {
    type: 'appCall';
}) | (OnlineKeyRegistrationParams & {
    type: 'keyReg';
}) | (algosdk.TransactionWithSigner & {
    type: 'txnWithSigner';
}) | {
    atc: algosdk.AtomicTransactionComposer;
    type: 'atc';
} | ((AppCallMethodCall | AppCreateMethodCall | AppUpdateMethodCall) & {
    type: 'methodCall';
});
/** Parameters to create an `AlgoKitComposer`. */
export type AlgoKitComposerParams = {
    /** The algod client to use to get suggestedParams and send the transaction group */
    algod: algosdk.Algodv2;
    /** The function used to get the TransactionSigner for a given address */
    getSigner: (address: string) => algosdk.TransactionSigner;
    /** The method used to get SuggestedParams for transactions in the group */
    getSuggestedParams?: () => Promise<algosdk.SuggestedParams>;
    /** How many rounds a transaction should be valid for by default; if not specified
     * then will be 10 rounds (or 1000 rounds if issuing transactions to LocalNet).
     */
    defaultValidityWindow?: number;
    /** An existing `AppManager` to use to manage app compilation and cache compilation results.
     *
     * If not specified than an ephemeral one will be created.
     */
    appManager?: AppManager;
};
/** Set of transactions built by `AlgoKitComposer`. */
export interface BuiltTransactions {
    /** The built transactions */
    transactions: algosdk.Transaction[];
    /** Any `ABIMethod` objects associated with any of the transactions in a map keyed by transaction index. */
    methodCalls: Map<number, algosdk.ABIMethod>;
    /** Any `TransactionSigner` objects associated with any of the transactions in a map keyed by transaction index. */
    signers: Map<number, algosdk.TransactionSigner>;
}
/** AlgoKit Composer helps you compose and execute transactions as a transaction group. */
export default class AlgoKitComposer {
    /** Signer used to represent a lack of signer */
    private static NULL_SIGNER;
    /** The ATC used to compose the group */
    private atc;
    /** Map of txid to ABI method */
    private txnMethodMap;
    /** Transactions that have not yet been composed */
    private txns;
    /** The algod client used by the composer. */
    private algod;
    /** An async function that will return suggested params for the transaction. */
    private getSuggestedParams;
    /** A function that takes in an address and return a signer function for that address. */
    private getSigner;
    /** The default transaction validity window */
    private defaultValidityWindow;
    /** Whether the validity window was explicitly set on construction */
    private defaultValidityWindowIsExplicit;
    private appManager;
    /**
     * Create an `AlgoKitComposer`.
     * @param params The configuration for this composer
     */
    constructor(params: AlgoKitComposerParams);
    /**
     * Add a pre-built transaction to the transaction group.
     * @param transaction The pre-built transaction
     * @param signer Optional signer override for the transaction
     * @returns The composer so you can chain method calls
     */
    addTransaction(transaction: Transaction, signer?: TransactionSigner): AlgoKitComposer;
    /**
     * Add a payment transaction to the transaction group.
     * @param params The payment transaction parameters
     * @returns The composer so you can chain method calls
     */
    addPayment(params: PaymentParams): AlgoKitComposer;
    /**
     * Add an asset create transaction to the transaction group.
     * @param params The asset create transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetCreate(params: AssetCreateParams): AlgoKitComposer;
    /**
     * Add an asset config transaction to the transaction group.
     * @param params The asset config transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetConfig(params: AssetConfigParams): AlgoKitComposer;
    /**
     * Add an asset freeze transaction to the transaction group.
     * @param params The asset freeze transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetFreeze(params: AssetFreezeParams): AlgoKitComposer;
    /**
     * Add an asset destroy transaction to the transaction group.
     * @param params The asset destroy transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetDestroy(params: AssetDestroyParams): AlgoKitComposer;
    /**
     * Add an asset transfer transaction to the transaction group.
     * @param params The asset transfer transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetTransfer(params: AssetTransferParams): AlgoKitComposer;
    /**
     * Add an asset opt-in transaction to the transaction group.
     * @param params The asset opt-in transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetOptIn(params: AssetOptInParams): AlgoKitComposer;
    /**
     * Add an asset opt-out transaction to the transaction group.
     * @param params The asset opt-out transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetOptOut(params: AssetOptOutParams): AlgoKitComposer;
    /**
     * Add an application create transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application create transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCreate(params: AppCreateParams): AlgoKitComposer;
    /**
     * Add an application update transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application update transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppUpdate(params: AppUpdateParams): AlgoKitComposer;
    /**
     * Add an application delete transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application delete transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppDelete(params: AppDeleteParams): AlgoKitComposer;
    /**
     * Add an application call transaction to the transaction group.
     *
     * If you want to create or update an app use `addAppCreate` or `addAppUpdate`.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCall(params: AppCallParams): AlgoKitComposer;
    /**
     * Add an ABI method create application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI create method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCreateMethodCall(params: AppCreateMethodCall): this;
    /**
     * Add an ABI method update application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI update method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppUpdateMethodCall(params: AppUpdateMethodCall): this;
    /**
     * Add an ABI method delete application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI delete method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppDeleteMethodCall(params: AppDeleteMethodCall): this;
    /**
     * Add a non-create/non-update ABI method application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCallMethodCall(params: AppCallMethodCall): this;
    /**
     * Add an online key registration transaction to the transaction group.
     * @param params The online key registration transaction parameters
     * @returns The composer so you can chain method calls
     */
    addOnlineKeyRegistration(params: OnlineKeyRegistrationParams): AlgoKitComposer;
    /**
     * Add the transactions within an `AtomicTransactionComposer` to the transaction group.
     * @param atc The `AtomicTransactionComposer` to build transactions from and add to the group
     * @returns The composer so you can chain method calls
     */
    addAtc(atc: algosdk.AtomicTransactionComposer): AlgoKitComposer;
    /** Build an ATC and return transactions ready to be incorporated into a broader set of transactions this composer is composing */
    private buildAtc;
    private commonTxnBuildStep;
    /**
     * Builds an ABI method call transaction and any other associated transactions represented in the ABI args.
     * @param includeSigner Whether to include the actual signer for the transactions.
     *  If you are just building transactions without signers yet then set this to `false`.
     */
    private buildMethodCall;
    private buildPayment;
    private buildAssetCreate;
    private buildAssetConfig;
    private buildAssetDestroy;
    private buildAssetFreeze;
    private buildAssetTransfer;
    private buildAppCall;
    private buildKeyReg;
    /** Builds all transaction types apart from `txnWithSigner`, `atc` and `methodCall` since those ones can have custom signers that need to be retrieved. */
    private buildTxn;
    private buildTxnWithSigner;
    /**
     * Compose all of the transactions without signers and return the transaction objects directly along with any ABI method calls.
     *
     * @returns The array of built transactions and any corresponding method calls
     */
    buildTransactions(): Promise<BuiltTransactions>;
    /**
     * Get the number of transactions currently added to this composer.
     */
    count(): Promise<number>;
    /**
     * Compose all of the transactions in a single atomic transaction group and an atomic transaction composer.
     *
     * You can then use the transactions standalone, or use the composer to execute or simulate the transactions.
     *
     * Once this method is called, no further transactions will be able to be added.
     * You can safely call this method multiple times to get the same result.
     * @returns The built atomic transaction composer and the transactions
     */
    build(): Promise<{
        atc: algosdk.AtomicTransactionComposer;
        transactions: algosdk.TransactionWithSigner[];
        methodCalls: any;
    }>;
    /**
     * Rebuild the group, discarding any previously built transactions.
     * This will potentially cause new signers and suggested params to be used if the callbacks return a new value compared to the first build.
     * @returns The newly built atomic transaction composer and the transactions
     */
    rebuild(): Promise<{
        atc: algosdk.AtomicTransactionComposer;
        transactions: algosdk.TransactionWithSigner[];
        methodCalls: any;
    }>;
    /**
     * Compose the atomic transaction group and send it to the network.
     * @param params The parameters to control execution with
     * @returns The execution result
     */
    send(params?: SendParams): Promise<SendAtomicTransactionComposerResults>;
    /**
     * @deprecated Use `send` instead.
     *
     * Compose the atomic transaction group and send it to the network
     *
     * An alias for `composer.send(params)`.
     * @param params The parameters to control execution with
     * @returns The execution result
     */
    execute(params?: SendParams): Promise<SendAtomicTransactionComposerResults>;
    /**
     * Compose the atomic transaction group and simulate sending it to the network
     * @returns The simulation result
     */
    simulate(options?: SimulateOptions): Promise<SendAtomicTransactionComposerResults & {
        simulateResponse: SimulateResponse;
    }>;
    /**
     * Create an encoded transaction note that follows the ARC-2 spec.
     *
     * https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0002.md
     * @param note The ARC-2 transaction note data
     * @returns The binary encoded transaction note
     */
    static arc2Note(note: Arc2TransactionNote): Uint8Array;
}
