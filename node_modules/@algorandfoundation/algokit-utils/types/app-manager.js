'use strict';

var algosdk = require('algosdk');
var types_app = require('./app.js');

var modelsv2 = algosdk.modelsv2;
/** Allows management of application information. */
class AppManager {
    /**
     * Creates an `AppManager`
     * @param algod An algod instance
     */
    constructor(algod) {
        this._compilationResults = {};
        this._algod = algod;
    }
    /**
     * Compiles the given TEAL using algod and returns the result, including source map.
     *
     * The result of this compilation is also cached keyed by the TEAL
     *  code so it can be retrieved via `getCompilationResult`.
     *
     * This function is re-entrant; it will only compile the same code once.
     *
     * @param tealCode The TEAL code
     * @returns The information about the compiled file
     */
    async compileTeal(tealCode) {
        if (this._compilationResults[tealCode]) {
            return this._compilationResults[tealCode];
        }
        const compiled = await this._algod.compile(tealCode).sourcemap(true).do();
        const result = {
            teal: tealCode,
            compiled: compiled.result,
            compiledHash: compiled.hash,
            compiledBase64ToBytes: new Uint8Array(Buffer.from(compiled.result, 'base64')),
            sourceMap: new algosdk.SourceMap(compiled['sourcemap']),
        };
        this._compilationResults[tealCode] = result;
        return result;
    }
    /**
     * Performs template substitution of a teal template and compiles it, returning the compiled result.
     *
     * Looks for `TMPL_{parameter}` for template replacements and replaces AlgoKit deploy-time control parameters
     * if deployment metadata is specified.
     *
     * * `TMPL_UPDATABLE` for updatability / immutability control
     * * `TMPL_DELETABLE` for deletability / permanence control
     *
     * @param tealTemplateCode The TEAL logic to compile
     * @param templateParams Any parameters to replace in the .teal file before compiling
     * @param deploymentMetadata The deployment metadata the app will be deployed with
     * @returns The information about the compiled code
     */
    async compileTealTemplate(tealTemplateCode, templateParams, deploymentMetadata) {
        let tealCode = AppManager.stripTealComments(tealTemplateCode);
        tealCode = AppManager.replaceTealTemplateParams(tealCode, templateParams);
        if (deploymentMetadata) {
            tealCode = AppManager.replaceTealTemplateDeployTimeControlParams(tealCode, deploymentMetadata);
        }
        return await this.compileTeal(tealCode);
    }
    /**
     * Returns a previous compilation result.
     * @param tealCode The TEAL code
     * @returns The information about the previously compiled file
     *  or `undefined` if that TEAL code wasn't previously compiled
     */
    getCompilationResult(tealCode) {
        return this._compilationResults[tealCode];
    }
    /**
     * Returns the current app information for the app with the given ID.
     *
     * @example
     * ```typescript
     * const appInfo = await appManager.getById(12353n);
     * ```
     *
     * @param appId The ID of the app
     * @returns The app information
     */
    async getById(appId) {
        const app = modelsv2.Application.from_obj_for_encoding(await this._algod.getApplicationByID(Number(appId)).do());
        return {
            appId: BigInt(app.id),
            appAddress: algosdk.getApplicationAddress(app.id),
            approvalProgram: app.params.approvalProgram,
            clearStateProgram: app.params.clearStateProgram,
            creator: app.params.creator,
            localInts: Number(app.params.localStateSchema?.numUint ?? 0),
            localByteSlices: Number(app.params.localStateSchema?.numByteSlice ?? 0),
            globalInts: Number(app.params.globalStateSchema?.numUint ?? 0),
            globalByteSlices: Number(app.params.globalStateSchema?.numByteSlice ?? 0),
            extraProgramPages: Number(app.params.extraProgramPages ?? 0),
            globalState: AppManager.decodeAppState(app.params.globalState ?? []),
        };
    }
    /**
     * Returns the current global state values for the given app ID and account address
     *
     * @param appId The ID of the app to return global state for
     * @returns The current global state for the given app
     */
    async getGlobalState(appId) {
        return (await this.getById(appId)).globalState;
    }
    /**
     * Returns the current local state values for the given app ID and account address
     *
     * @param appId The ID of the app to return local state for
     * @param address The string address of the account to get local state for the given app
     * @returns The current local state for the given (app, account) combination
     */
    async getLocalState(appId, address) {
        const appInfo = modelsv2.AccountApplicationResponse.from_obj_for_encoding(await this._algod.accountApplicationInformation(address, Number(appId)).do());
        if (!appInfo.appLocalState?.keyValue) {
            throw new Error("Couldn't find local state");
        }
        return AppManager.decodeAppState(appInfo.appLocalState.keyValue);
    }
    /**
     * Returns the names of the current boxes for the given app.
     * @param appId The ID of the app return box names for
     * @returns The current box names
     */
    async getBoxNames(appId) {
        const boxResult = await this._algod.getApplicationBoxes(Number(appId)).do();
        return boxResult.boxes.map((b) => {
            return {
                nameRaw: b.name,
                nameBase64: Buffer.from(b.name).toString('base64'),
                name: Buffer.from(b.name).toString('utf-8'),
            };
        });
    }
    /**
     * Returns the value of the given box name for the given app.
     * @param appId The ID of the app return box names for
     * @param boxName The name of the box to return either as a string, binary array or `BoxName`
     * @returns The current box value as a byte array
     */
    async getBoxValue(appId, boxName) {
        const name = AppManager.getBoxReference(boxName).name;
        const boxResult = await this._algod.getApplicationBoxByName(Number(appId), name).do();
        return boxResult.value;
    }
    /**
     * Returns the value of the given box names for the given app.
     * @param appId The ID of the app return box names for
     * @param boxNames The names of the boxes to return either as a string, binary array or `BoxName`
     * @returns The current box values as a byte array in the same order as the passed in box names
     */
    async getBoxValues(appId, boxNames) {
        return await Promise.all(boxNames.map(async (boxName) => await this.getBoxValue(appId, boxName)));
    }
    /**
     * Returns the value of the given box name for the given app decoded based on the given ABI type.
     * @param request The parameters for the box value request
     * @returns The current box value as an ABI value
     */
    async getBoxValueFromABIType(request) {
        const { appId, boxName, type } = request;
        const value = await this.getBoxValue(appId, boxName);
        return type.decode(value);
    }
    /**
     * Returns the value of the given box names for the given app decoded based on the given ABI type.
     * @param request The parameters for the box value request
     * @returns The current box values as an ABI value in the same order as the passed in box names
     */
    async getBoxValuesFromABIType(request) {
        const { appId, boxNames, type } = request;
        return await Promise.all(boxNames.map(async (boxName) => await this.getBoxValueFromABIType({ appId, boxName, type })));
    }
    /**
     * Returns a `algosdk.BoxReference` given a `BoxIdentifier` or `BoxReference`.
     * @param boxId The box to return a reference for
     * @returns The box reference ready to pass into a `algosdk.Transaction`
     */
    static getBoxReference(boxId) {
        const ref = typeof boxId === 'object' && 'appId' in boxId ? boxId : { appId: 0n, name: boxId };
        return {
            appIndex: Number(ref.appId),
            name: typeof ref.name === 'string'
                ? new TextEncoder().encode(ref.name)
                : 'length' in ref.name
                    ? ref.name
                    : algosdk.decodeAddress(ref.name.addr).publicKey,
        };
    }
    /**
     * Converts an array of global/local state values from the algod api to a more friendly
     * generic object keyed by the UTF-8 value of the key.
     * @param state A `global-state`, `local-state`, `global-state-deltas` or `local-state-deltas`
     * @returns An object keyeed by the UTF-8 representation of the key with various parsings of the values
     */
    static decodeAppState(state) {
        const stateValues = {};
        // Start with empty set
        for (const stateVal of state) {
            const keyBase64 = stateVal.key;
            const keyRaw = Buffer.from(keyBase64, 'base64');
            const key = keyRaw.toString('utf-8');
            const tealValue = stateVal.value;
            const dataTypeFlag = 'action' in tealValue ? tealValue.action : tealValue.type;
            let valueBase64;
            let valueRaw;
            switch (dataTypeFlag) {
                case 1:
                    valueBase64 = tealValue.bytes ?? '';
                    valueRaw = Buffer.from(valueBase64, 'base64');
                    stateValues[key] = {
                        keyRaw,
                        keyBase64,
                        valueRaw: new Uint8Array(valueRaw),
                        valueBase64: valueBase64,
                        value: valueRaw.toString('utf-8'),
                    };
                    break;
                case 2: {
                    const value = tealValue.uint ?? 0;
                    stateValues[key] = {
                        keyRaw,
                        keyBase64,
                        value: BigInt(value),
                    };
                    break;
                }
                default:
                    throw new Error(`Received unknown state data type of ${dataTypeFlag}`);
            }
        }
        return stateValues;
    }
    /**
     * Returns any ABI return values for the given app call arguments and transaction confirmation.
     * @param confirmation The transaction confirmation from algod
     * @param method The ABI method
     * @returns The return value for the method call
     */
    static getABIReturn(confirmation, method) {
        if (!method || !confirmation || method.returns.type === 'void') {
            return undefined;
        }
        // The parseMethodResponse method mutates the second parameter :(
        const resultDummy = {
            txID: '',
            method,
            rawReturnValue: new Uint8Array(),
        };
        const response = algosdk.AtomicTransactionComposer.parseMethodResponse(method, resultDummy, confirmation);
        return !response.decodeError
            ? {
                rawReturnValue: response.rawReturnValue,
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                returnValue: response.returnValue,
                decodeError: undefined,
            }
            : {
                rawReturnValue: undefined,
                returnValue: undefined,
                decodeError: response.decodeError,
            };
    }
    /**
     * Replaces AlgoKit deploy-time deployment control parameters within the given TEAL template code.
     *
     * * `TMPL_UPDATABLE` for updatability / immutability control
     * * `TMPL_DELETABLE` for deletability / permanence control
     *
     * Note: If these values are defined, but the corresponding `TMPL_*` value
     *  isn't in the teal code it will throw an exception.
     *
     * @param tealTemplateCode The TEAL template code to substitute
     * @param params The deploy-time deployment control parameter value to replace
     * @returns The replaced TEAL code
     */
    static replaceTealTemplateDeployTimeControlParams(tealTemplateCode, params) {
        if (params.updatable !== undefined) {
            if (!tealTemplateCode.includes(types_app.UPDATABLE_TEMPLATE_NAME)) {
                throw new Error(`Deploy-time updatability control requested for app deployment, but ${types_app.UPDATABLE_TEMPLATE_NAME} not present in TEAL code`);
            }
            tealTemplateCode = tealTemplateCode.replace(new RegExp(types_app.UPDATABLE_TEMPLATE_NAME, 'g'), (params.updatable ? 1 : 0).toString());
        }
        if (params.deletable !== undefined) {
            if (!tealTemplateCode.includes(types_app.DELETABLE_TEMPLATE_NAME)) {
                throw new Error(`Deploy-time deletability control requested for app deployment, but ${types_app.DELETABLE_TEMPLATE_NAME} not present in TEAL code`);
            }
            tealTemplateCode = tealTemplateCode.replace(new RegExp(types_app.DELETABLE_TEMPLATE_NAME, 'g'), (params.deletable ? 1 : 0).toString());
        }
        return tealTemplateCode;
    }
    /**
     * Performs template substitution of a teal file.
     *
     * Looks for `TMPL_{parameter}` for template replacements.
     *
     * @param tealTemplateCode The TEAL template code to make parameter replacements in
     * @param templateParams Any parameters to replace in the teal code
     * @returns The TEAL code with replacements
     */
    static replaceTealTemplateParams(tealTemplateCode, templateParams) {
        if (templateParams !== undefined) {
            for (const key in templateParams) {
                const value = templateParams[key];
                const token = `TMPL_${key.replace(/^TMPL_/, '')}`;
                // If this is a number, first replace any byte representations of the number
                // These may appear in the TEAL in order to circumvent int compression and preserve PC values
                if (typeof value === 'number' || typeof value === 'bigint') {
                    tealTemplateCode = tealTemplateCode.replace(new RegExp(`(?<=bytes )${token}`, 'g'), `0x${value.toString(16).padStart(16, '0')}`);
                    // We could probably return here since mixing pushint and pushbytes is likely not going to happen, but might as well do both
                }
                tealTemplateCode = tealTemplateCode.replace(new RegExp(token, 'g'), typeof value === 'string'
                    ? `0x${Buffer.from(value, 'utf-8').toString('hex')}`
                    : ArrayBuffer.isView(value)
                        ? `0x${Buffer.from(value).toString('hex')}`
                        : value.toString());
            }
        }
        return tealTemplateCode;
    }
    /**
     * Remove comments from TEAL code (useful to reduce code size before compilation).
     *
     * @param tealCode The TEAL logic to strip
     * @returns The TEAL without comments
     */
    static stripTealComments(tealCode) {
        // find // outside quotes, i.e. won't pick up "//not a comment"
        const regex = /\/\/(?=([^"\\]*(\\.|"([^"\\]*\\.)*[^"\\]*"))*[^"]*$)/;
        tealCode = tealCode
            .split('\n')
            .map((tealCodeLine) => {
            return tealCodeLine.split(regex)[0].trim();
        })
            .join('\n');
        return tealCode;
    }
}

exports.AppManager = AppManager;
//# sourceMappingURL=app-manager.js.map
