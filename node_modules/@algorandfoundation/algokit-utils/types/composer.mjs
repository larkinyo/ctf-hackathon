import algosdk from 'algosdk';
import { Config } from '../config.mjs';
import { performAtomicTransactionComposerSimulate } from '../transaction/perform-atomic-transaction-composer-simulate.mjs';
import { encodeLease, sendAtomicTransactionComposer } from '../transaction/transaction.mjs';
import { APP_PAGE_MAX_SIZE } from './app.mjs';
import { AppManager } from './app-manager.mjs';
import { EventType } from './async-event-emitter.mjs';
import { genesisIdIsLocalNet } from './network-client.mjs';

var isTransactionWithSigner = algosdk.isTransactionWithSigner;
var encodeAddress = algosdk.encodeAddress;
var modelsv2 = algosdk.modelsv2;
const MAX_TRANSACTION_GROUP_SIZE = 16;
/** AlgoKit Composer helps you compose and execute transactions as a transaction group. */
class AlgoKitComposer {
    /**
     * Create an `AlgoKitComposer`.
     * @param params The configuration for this composer
     */
    constructor(params) {
        /** The ATC used to compose the group */
        this.atc = new algosdk.AtomicTransactionComposer();
        /** Map of txid to ABI method */
        this.txnMethodMap = new Map();
        /** Transactions that have not yet been composed */
        this.txns = [];
        /** The default transaction validity window */
        this.defaultValidityWindow = 10;
        /** Whether the validity window was explicitly set on construction */
        this.defaultValidityWindowIsExplicit = false;
        this.algod = params.algod;
        const defaultGetSuggestedParams = () => params.algod.getTransactionParams().do();
        this.getSuggestedParams = params.getSuggestedParams ?? defaultGetSuggestedParams;
        this.getSigner = params.getSigner;
        this.defaultValidityWindow = params.defaultValidityWindow ?? this.defaultValidityWindow;
        this.defaultValidityWindowIsExplicit = params.defaultValidityWindow !== undefined;
        this.appManager = params.appManager ?? new AppManager(params.algod);
    }
    /**
     * Add a pre-built transaction to the transaction group.
     * @param transaction The pre-built transaction
     * @param signer Optional signer override for the transaction
     * @returns The composer so you can chain method calls
     */
    addTransaction(transaction, signer) {
        this.txns.push({
            txn: transaction,
            signer: signer ?? this.getSigner(algosdk.encodeAddress(transaction.from.publicKey)),
            type: 'txnWithSigner',
        });
        return this;
    }
    /**
     * Add a payment transaction to the transaction group.
     * @param params The payment transaction parameters
     * @returns The composer so you can chain method calls
     */
    addPayment(params) {
        this.txns.push({ ...params, type: 'pay' });
        return this;
    }
    /**
     * Add an asset create transaction to the transaction group.
     * @param params The asset create transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetCreate(params) {
        this.txns.push({ ...params, type: 'assetCreate' });
        return this;
    }
    /**
     * Add an asset config transaction to the transaction group.
     * @param params The asset config transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetConfig(params) {
        this.txns.push({ ...params, type: 'assetConfig' });
        return this;
    }
    /**
     * Add an asset freeze transaction to the transaction group.
     * @param params The asset freeze transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetFreeze(params) {
        this.txns.push({ ...params, type: 'assetFreeze' });
        return this;
    }
    /**
     * Add an asset destroy transaction to the transaction group.
     * @param params The asset destroy transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetDestroy(params) {
        this.txns.push({ ...params, type: 'assetDestroy' });
        return this;
    }
    /**
     * Add an asset transfer transaction to the transaction group.
     * @param params The asset transfer transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetTransfer(params) {
        this.txns.push({ ...params, type: 'assetTransfer' });
        return this;
    }
    /**
     * Add an asset opt-in transaction to the transaction group.
     * @param params The asset opt-in transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetOptIn(params) {
        this.txns.push({ ...params, type: 'assetOptIn' });
        return this;
    }
    /**
     * Add an asset opt-out transaction to the transaction group.
     * @param params The asset opt-out transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAssetOptOut(params) {
        this.txns.push({ ...params, type: 'assetOptOut' });
        return this;
    }
    /**
     * Add an application create transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application create transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCreate(params) {
        this.txns.push({ ...params, type: 'appCall' });
        return this;
    }
    /**
     * Add an application update transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application update transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppUpdate(params) {
        this.txns.push({ ...params, type: 'appCall', onComplete: algosdk.OnApplicationComplete.UpdateApplicationOC });
        return this;
    }
    /**
     * Add an application delete transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application delete transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppDelete(params) {
        this.txns.push({ ...params, type: 'appCall', onComplete: algosdk.OnApplicationComplete.DeleteApplicationOC });
        return this;
    }
    /**
     * Add an application call transaction to the transaction group.
     *
     * If you want to create or update an app use `addAppCreate` or `addAppUpdate`.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCall(params) {
        this.txns.push({ ...params, type: 'appCall' });
        return this;
    }
    /**
     * Add an ABI method create application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI create method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCreateMethodCall(params) {
        this.txns.push({ ...params, type: 'methodCall' });
        return this;
    }
    /**
     * Add an ABI method update application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI update method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppUpdateMethodCall(params) {
        this.txns.push({ ...params, type: 'methodCall', onComplete: algosdk.OnApplicationComplete.UpdateApplicationOC });
        return this;
    }
    /**
     * Add an ABI method delete application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI delete method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppDeleteMethodCall(params) {
        this.txns.push({ ...params, type: 'methodCall', onComplete: algosdk.OnApplicationComplete.DeleteApplicationOC });
        return this;
    }
    /**
     * Add a non-create/non-update ABI method application call transaction to the transaction group.
     *
     * Note: we recommend using app clients to make it easier to make app calls.
     * @param params The ABI method application call transaction parameters
     * @returns The composer so you can chain method calls
     */
    addAppCallMethodCall(params) {
        this.txns.push({ ...params, type: 'methodCall' });
        return this;
    }
    /**
     * Add an online key registration transaction to the transaction group.
     * @param params The online key registration transaction parameters
     * @returns The composer so you can chain method calls
     */
    addOnlineKeyRegistration(params) {
        this.txns.push({ ...params, type: 'keyReg' });
        return this;
    }
    /**
     * Add the transactions within an `AtomicTransactionComposer` to the transaction group.
     * @param atc The `AtomicTransactionComposer` to build transactions from and add to the group
     * @returns The composer so you can chain method calls
     */
    addAtc(atc) {
        this.txns.push({ atc, type: 'atc' });
        return this;
    }
    /** Build an ATC and return transactions ready to be incorporated into a broader set of transactions this composer is composing */
    buildAtc(atc, processTransaction) {
        const group = atc.buildGroup();
        const txnWithSigners = group.map((ts, idx) => {
            // Remove underlying group ID from the transaction since it will be re-grouped when this AlgoKitComposer is built
            ts.txn.group = undefined;
            // Process transaction if a function is provided
            ts.txn = processTransaction?.(ts.txn, idx) ?? ts.txn;
            // If this was a method call stash the ABIMethod for later
            if (atc['methodCalls'].get(idx)) {
                this.txnMethodMap.set(ts.txn.txID(), atc['methodCalls'].get(idx));
            }
            return ts;
        });
        return txnWithSigners;
    }
    commonTxnBuildStep(params, txn, suggestedParams) {
        if (params.lease)
            txn.addLease(encodeLease(params.lease));
        if (params.rekeyTo)
            txn.addRekey(params.rekeyTo);
        const encoder = new TextEncoder();
        if (params.note)
            txn.note = typeof params.note === 'string' ? encoder.encode(params.note) : params.note;
        if (params.firstValidRound) {
            txn.firstRound = Number(params.firstValidRound);
        }
        if (params.lastValidRound) {
            txn.lastRound = Number(params.lastValidRound);
        }
        else {
            // If the validity window isn't set in this transaction or by default and we are pointing at
            //  LocalNet set a bigger window to avoid dead transactions
            const window = params.validityWindow ??
                (!this.defaultValidityWindowIsExplicit && genesisIdIsLocalNet(suggestedParams.genesisID) ? 1000 : this.defaultValidityWindow);
            txn.lastRound = txn.firstRound + window;
        }
        if (params.staticFee !== undefined && params.extraFee !== undefined) {
            throw Error('Cannot set both staticFee and extraFee');
        }
        if (params.staticFee !== undefined) {
            txn.fee = Number(params.staticFee.microAlgo);
        }
        else {
            txn.fee = txn.estimateSize() * suggestedParams.fee || algosdk.ALGORAND_MIN_TX_FEE;
            if (params.extraFee)
                txn.fee += Number(params.extraFee.microAlgo);
        }
        txn.flatFee = true;
        if (params.maxFee !== undefined && txn.fee > params.maxFee.microAlgo) {
            throw Error(`Transaction fee ${txn.fee} ÂµALGO is greater than maxFee ${params.maxFee}`);
        }
        return txn;
    }
    /**
     * Builds an ABI method call transaction and any other associated transactions represented in the ABI args.
     * @param includeSigner Whether to include the actual signer for the transactions.
     *  If you are just building transactions without signers yet then set this to `false`.
     */
    async buildMethodCall(params, suggestedParams, includeSigner) {
        const methodArgs = [];
        const isAbiValue = (x) => {
            if (Array.isArray(x))
                return x.length == 0 || x.every(isAbiValue);
            return typeof x === 'bigint' || typeof x === 'boolean' || typeof x === 'number' || typeof x === 'string' || x instanceof Uint8Array;
        };
        for (let i = 0; i < (params.args ?? []).length; i++) {
            const arg = params.args[i];
            if (arg === undefined) {
                throw Error(`No value provided for argument ${i + 1} within call to ${params.method.name}`);
            }
            if (isAbiValue(arg)) {
                methodArgs.push(arg);
                continue;
            }
            if (isTransactionWithSigner(arg)) {
                methodArgs.push(arg);
                continue;
            }
            if ('method' in arg) {
                const tempTxnWithSigners = await this.buildMethodCall(arg, suggestedParams, includeSigner);
                methodArgs.push(...tempTxnWithSigners);
                continue;
            }
            const txn = await arg;
            methodArgs.push({
                txn,
                signer: includeSigner
                    ? params.signer
                        ? 'signer' in params.signer
                            ? params.signer.signer
                            : params.signer
                        : this.getSigner(encodeAddress(txn.from.publicKey))
                    : AlgoKitComposer.NULL_SIGNER,
            });
        }
        const methodAtc = new algosdk.AtomicTransactionComposer();
        const appId = Number('appId' in params ? params.appId : 0n);
        const approvalProgram = 'approvalProgram' in params
            ? typeof params.approvalProgram === 'string'
                ? (await this.appManager.compileTeal(params.approvalProgram)).compiledBase64ToBytes
                : params.approvalProgram
            : undefined;
        const clearStateProgram = 'clearStateProgram' in params
            ? typeof params.clearStateProgram === 'string'
                ? (await this.appManager.compileTeal(params.clearStateProgram)).compiledBase64ToBytes
                : params.clearStateProgram
            : undefined;
        methodAtc.addMethodCall({
            appID: appId,
            sender: params.sender,
            suggestedParams,
            onComplete: params.onComplete ?? algosdk.OnApplicationComplete.NoOpOC,
            appAccounts: params.accountReferences,
            appForeignApps: params.appReferences?.map((x) => Number(x)),
            appForeignAssets: params.assetReferences?.map((x) => Number(x)),
            boxes: params.boxReferences?.map(AppManager.getBoxReference),
            approvalProgram,
            clearProgram: clearStateProgram,
            extraPages: appId === 0
                ? 'extraProgramPages' in params && params.extraProgramPages !== undefined
                    ? params.extraProgramPages
                    : approvalProgram
                        ? Math.floor((approvalProgram.length + (clearStateProgram?.length ?? 0)) / APP_PAGE_MAX_SIZE)
                        : 0
                : undefined,
            numLocalInts: appId === 0 ? ('schema' in params ? params.schema?.localInts ?? 0 : 0) : undefined,
            numLocalByteSlices: appId === 0 ? ('schema' in params ? params.schema?.localByteSlices ?? 0 : 0) : undefined,
            numGlobalInts: appId === 0 ? ('schema' in params ? params.schema?.globalInts ?? 0 : 0) : undefined,
            numGlobalByteSlices: appId === 0 ? ('schema' in params ? params.schema?.globalByteSlices ?? 0 : 0) : undefined,
            method: params.method,
            signer: includeSigner
                ? params.signer
                    ? 'signer' in params.signer
                        ? params.signer.signer
                        : params.signer
                    : this.getSigner(params.sender)
                : AlgoKitComposer.NULL_SIGNER,
            methodArgs: methodArgs,
            // note, lease, and rekeyTo are set in the common build step
            note: undefined,
            lease: undefined,
            rekeyTo: undefined,
        });
        // Process the ATC to get a set of transactions ready for broader grouping
        //  and with the common build step to set fees and validity rounds
        return this.buildAtc(methodAtc, (txn, idx) => idx === methodAtc.count() - 1 ? this.commonTxnBuildStep(params, txn, suggestedParams) : txn);
    }
    buildPayment(params, suggestedParams) {
        const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
            from: params.sender,
            to: params.receiver,
            amount: params.amount.microAlgo,
            closeRemainderTo: params.closeRemainderTo,
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetCreate(params, suggestedParams) {
        const txn = algosdk.makeAssetCreateTxnWithSuggestedParamsFromObject({
            from: params.sender,
            total: params.total,
            decimals: params.decimals ?? 0,
            assetName: params.assetName,
            unitName: params.unitName,
            assetURL: params.url,
            defaultFrozen: params.defaultFrozen ?? false,
            assetMetadataHash: params.metadataHash,
            manager: params.manager,
            reserve: params.reserve,
            freeze: params.freeze,
            clawback: params.clawback,
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetConfig(params, suggestedParams) {
        const txn = algosdk.makeAssetConfigTxnWithSuggestedParamsFromObject({
            from: params.sender,
            assetIndex: Number(params.assetId),
            suggestedParams,
            manager: params.manager,
            reserve: params.reserve,
            freeze: params.freeze,
            clawback: params.clawback,
            strictEmptyAddressChecking: false,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetDestroy(params, suggestedParams) {
        const txn = algosdk.makeAssetDestroyTxnWithSuggestedParamsFromObject({
            from: params.sender,
            assetIndex: Number(params.assetId),
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetFreeze(params, suggestedParams) {
        const txn = algosdk.makeAssetFreezeTxnWithSuggestedParamsFromObject({
            from: params.sender,
            assetIndex: Number(params.assetId),
            freezeTarget: params.account,
            freezeState: params.frozen,
            suggestedParams,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildAssetTransfer(params, suggestedParams) {
        const txn = algosdk.makeAssetTransferTxnWithSuggestedParamsFromObject({
            from: params.sender,
            to: params.receiver,
            assetIndex: Number(params.assetId),
            amount: params.amount,
            suggestedParams,
            closeRemainderTo: params.closeAssetTo,
            revocationTarget: params.clawbackTarget,
        });
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    async buildAppCall(params, suggestedParams) {
        const appId = Number('appId' in params ? params.appId : 0n);
        const approvalProgram = 'approvalProgram' in params
            ? typeof params.approvalProgram === 'string'
                ? (await this.appManager.compileTeal(params.approvalProgram)).compiledBase64ToBytes
                : params.approvalProgram
            : undefined;
        const clearStateProgram = 'clearStateProgram' in params
            ? typeof params.clearStateProgram === 'string'
                ? (await this.appManager.compileTeal(params.clearStateProgram)).compiledBase64ToBytes
                : params.clearStateProgram
            : undefined;
        const sdkParams = {
            from: params.sender,
            suggestedParams,
            appArgs: params.args,
            onComplete: params.onComplete ?? algosdk.OnApplicationComplete.NoOpOC,
            accounts: params.accountReferences,
            foreignApps: params.appReferences?.map((x) => Number(x)),
            foreignAssets: params.assetReferences?.map((x) => Number(x)),
            boxes: params.boxReferences?.map(AppManager.getBoxReference),
            approvalProgram,
            clearProgram: clearStateProgram,
        };
        let txn;
        if (appId === 0) {
            if (sdkParams.approvalProgram === undefined || sdkParams.clearProgram === undefined) {
                throw new Error('approvalProgram and clearStateProgram are required for application creation');
            }
            txn = algosdk.makeApplicationCreateTxnFromObject({
                ...sdkParams,
                extraPages: 'extraProgramPages' in params
                    ? params.extraProgramPages ?? Math.floor((approvalProgram.length + clearStateProgram.length) / APP_PAGE_MAX_SIZE)
                    : 0,
                numLocalInts: 'schema' in params ? params.schema?.localInts ?? 0 : 0,
                numLocalByteSlices: 'schema' in params ? params.schema?.localByteSlices ?? 0 : 0,
                numGlobalInts: 'schema' in params ? params.schema?.globalInts ?? 0 : 0,
                numGlobalByteSlices: 'schema' in params ? params.schema?.globalByteSlices ?? 0 : 0,
                approvalProgram: approvalProgram,
                clearProgram: clearStateProgram,
            });
        }
        else {
            txn = algosdk.makeApplicationCallTxnFromObject({ ...sdkParams, appIndex: appId });
        }
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    buildKeyReg(params, suggestedParams) {
        const txn = algosdk.makeKeyRegistrationTxnWithSuggestedParams(params.sender, undefined, params.voteKey, params.selectionKey, Number(params.voteFirst), Number(params.voteLast), Number(params.voteKeyDilution), suggestedParams, undefined, false, params.stateProofKey);
        return this.commonTxnBuildStep(params, txn, suggestedParams);
    }
    /** Builds all transaction types apart from `txnWithSigner`, `atc` and `methodCall` since those ones can have custom signers that need to be retrieved. */
    async buildTxn(txn, suggestedParams) {
        switch (txn.type) {
            case 'pay':
                return [this.buildPayment(txn, suggestedParams)];
            case 'assetCreate':
                return [this.buildAssetCreate(txn, suggestedParams)];
            case 'appCall':
                return [await this.buildAppCall(txn, suggestedParams)];
            case 'assetConfig':
                return [this.buildAssetConfig(txn, suggestedParams)];
            case 'assetDestroy':
                return [this.buildAssetDestroy(txn, suggestedParams)];
            case 'assetFreeze':
                return [this.buildAssetFreeze(txn, suggestedParams)];
            case 'assetTransfer':
                return [this.buildAssetTransfer(txn, suggestedParams)];
            case 'assetOptIn':
                return [this.buildAssetTransfer({ ...txn, receiver: txn.sender, amount: 0n }, suggestedParams)];
            case 'assetOptOut':
                return [this.buildAssetTransfer({ ...txn, receiver: txn.sender, amount: 0n, closeAssetTo: txn.creator }, suggestedParams)];
            case 'keyReg':
                return [this.buildKeyReg(txn, suggestedParams)];
            default:
                throw Error(`Unsupported txn type`);
        }
    }
    async buildTxnWithSigner(txn, suggestedParams) {
        if (txn.type === 'txnWithSigner') {
            return [txn];
        }
        if (txn.type === 'atc') {
            return this.buildAtc(txn.atc);
        }
        if (txn.type === 'methodCall') {
            return await this.buildMethodCall(txn, suggestedParams, true);
        }
        const signer = txn.signer ? ('signer' in txn.signer ? txn.signer.signer : txn.signer) : this.getSigner(txn.sender);
        return (await this.buildTxn(txn, suggestedParams)).map((txn) => ({ txn, signer }));
    }
    /**
     * Compose all of the transactions without signers and return the transaction objects directly along with any ABI method calls.
     *
     * @returns The array of built transactions and any corresponding method calls
     */
    async buildTransactions() {
        const suggestedParams = await this.getSuggestedParams();
        const transactions = [];
        const methodCalls = new Map();
        const signers = new Map();
        for (const txn of this.txns) {
            if (!['txnWithSigner', 'atc', 'methodCall'].includes(txn.type)) {
                transactions.push(...(await this.buildTxn(txn, suggestedParams)));
            }
            else {
                const transactionsWithSigner = txn.type === 'txnWithSigner'
                    ? [txn]
                    : txn.type === 'atc'
                        ? this.buildAtc(txn.atc)
                        : txn.type === 'methodCall'
                            ? await this.buildMethodCall(txn, suggestedParams, false)
                            : [];
                transactions.push(...transactionsWithSigner.map((ts) => ts.txn));
                transactionsWithSigner.forEach((ts, idx) => {
                    if (ts.signer && ts.signer !== AlgoKitComposer.NULL_SIGNER) {
                        signers.set(idx, ts.signer);
                    }
                });
            }
        }
        for (let i = 0; i < transactions.length; i++) {
            const method = this.txnMethodMap.get(transactions[i].txID());
            if (method)
                methodCalls.set(i, method);
        }
        return { transactions, methodCalls, signers };
    }
    /**
     * Get the number of transactions currently added to this composer.
     */
    async count() {
        return (await this.buildTransactions()).transactions.length;
    }
    /**
     * Compose all of the transactions in a single atomic transaction group and an atomic transaction composer.
     *
     * You can then use the transactions standalone, or use the composer to execute or simulate the transactions.
     *
     * Once this method is called, no further transactions will be able to be added.
     * You can safely call this method multiple times to get the same result.
     * @returns The built atomic transaction composer and the transactions
     */
    async build() {
        if (this.atc.getStatus() === algosdk.AtomicTransactionComposerStatus.BUILDING) {
            const suggestedParams = await this.getSuggestedParams();
            // Build all of the transactions
            const txnWithSigners = [];
            for (const txn of this.txns) {
                txnWithSigners.push(...(await this.buildTxnWithSigner(txn, suggestedParams)));
            }
            // Add all of the transactions to the underlying ATC
            const methodCalls = new Map();
            txnWithSigners.forEach((ts, idx) => {
                this.atc.addTransaction(ts);
                // Populate consolidated set of all ABI method calls
                const method = this.txnMethodMap.get(ts.txn.txID());
                if (method)
                    methodCalls.set(idx, method);
            });
            this.atc['methodCalls'] = methodCalls;
        }
        return { atc: this.atc, transactions: this.atc.buildGroup(), methodCalls: this.atc['methodCalls'] };
    }
    /**
     * Rebuild the group, discarding any previously built transactions.
     * This will potentially cause new signers and suggested params to be used if the callbacks return a new value compared to the first build.
     * @returns The newly built atomic transaction composer and the transactions
     */
    async rebuild() {
        this.atc = new algosdk.AtomicTransactionComposer();
        return await this.build();
    }
    /**
     * Compose the atomic transaction group and send it to the network.
     * @param params The parameters to control execution with
     * @returns The execution result
     */
    async send(params) {
        const group = (await this.build()).transactions;
        let waitRounds = params?.maxRoundsToWaitForConfirmation;
        if (waitRounds === undefined) {
            const lastRound = group.reduce((max, txn) => Math.max(txn.txn.lastRound, max), 0);
            const { firstRound } = await this.getSuggestedParams();
            waitRounds = lastRound - firstRound + 1;
        }
        return await sendAtomicTransactionComposer({
            atc: this.atc,
            suppressLog: params?.suppressLog,
            maxRoundsToWaitForConfirmation: waitRounds,
            populateAppCallResources: params?.populateAppCallResources,
        }, this.algod);
    }
    /**
     * @deprecated Use `send` instead.
     *
     * Compose the atomic transaction group and send it to the network
     *
     * An alias for `composer.send(params)`.
     * @param params The parameters to control execution with
     * @returns The execution result
     */
    async execute(params) {
        return this.send(params);
    }
    /**
     * Compose the atomic transaction group and simulate sending it to the network
     * @returns The simulation result
     */
    async simulate(options) {
        await this.build();
        if (Config.debug && !Config.traceAll) {
            // Dump the traces to a file for use with AlgoKit AVM debugger
            // Checks for false on traceAll because it should have been already
            // executed above
            const simulateResponse = await performAtomicTransactionComposerSimulate(this.atc, this.algod);
            await Config.events.emitAsync(EventType.TxnGroupSimulated, {
                simulateResponse,
            });
        }
        const { methodResults, simulateResponse } = await this.atc.simulate(this.algod, new modelsv2.SimulateRequest({ txnGroups: [], ...options }));
        if (simulateResponse && simulateResponse.txnGroups[0].failedAt) {
            const error = new Error(`Transaction failed at transaction(s) ${simulateResponse.txnGroups[0].failedAt.join(', ')} in the group. ${simulateResponse.txnGroups.find((x) => x.failureMessage)?.failureMessage}`);
            error.simulateResponse = simulateResponse;
            throw error;
        }
        const transactions = this.atc.buildGroup().map((t) => t.txn);
        return {
            confirmations: simulateResponse.txnGroups[0].txnResults.map((t) => t.txnResult),
            transactions: transactions,
            txIds: transactions.map((t) => t.txID()),
            groupId: Buffer.from(transactions[0].group ?? new Uint8Array()).toString('base64'),
            simulateResponse,
            returns: methodResults.map((m) => m),
        };
    }
    /**
     * Create an encoded transaction note that follows the ARC-2 spec.
     *
     * https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0002.md
     * @param note The ARC-2 transaction note data
     * @returns The binary encoded transaction note
     */
    static arc2Note(note) {
        const arc2Payload = `${note.dAppName}:${note.format}${typeof note.data === 'string' ? note.data : JSON.stringify(note.data)}`;
        const encoder = new TextEncoder();
        return encoder.encode(arc2Payload);
    }
}
/** Signer used to represent a lack of signer */
AlgoKitComposer.NULL_SIGNER = algosdk.makeEmptyTransactionSigner();

export { MAX_TRANSACTION_GROUP_SIZE, AlgoKitComposer as default };
//# sourceMappingURL=composer.mjs.map
